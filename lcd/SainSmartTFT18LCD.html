<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://obniz.io/js/jquery-3.2.1.min.js"></script>
  <script src="https://unpkg.com/obniz@1.10.0/obniz.js" crossorigin="anonymous"></script>

<!--  <script src="https://ssl.nak435.com/obniz/obniz.js"></script> -->
  <link rel="stylesheet" type="text/css" href="https://ssl.nak435.com/obniz/obniz.css">
</head>
<body>

<div id="obniz-debug"></div>

<h2>SainSmart ST7735 1.8" TFT LCD 128x160 pixel (SPI interface)</h2>
<h1>デモ</h1>
<div id="panel" style="display:none;">
  <table>
    <tr><td>
      <select id="sel" size="14" style="font-size: 14pt;" disabled>
        <option value="0">&nbsp; 1.塗りつぶし</option>
        <option value="1">&nbsp; 2.線</option>
        <option value="2">&nbsp; 3.四角</option>
        <option value="3">&nbsp; 4.三角</option>
        <option value="4">&nbsp; 5.丸</option>
        <option value="5">&nbsp; 6.文字</option>
        <option value="6">&nbsp; 7.反転</option>
        <option value="7">&nbsp; 8.white</option>
        <option value="8">&nbsp; 9.black</option>
        <option value="9">10.文章(1文字づつ)</option>
        <option value="10">11.文章(1行づつ)</option>
        <option value="11">12.回転</option>
        <option value="12">13.イメージ描画(カラー)</option>
        <option value="13">14.イメージ描画(グレイスケール)</option>
      </select>
    </td></tr>
    <tr><td><div style="background-color:yellow; font-size: 14pt;">
      イメージファイル
      <input id="ufile" type="file" accept="image/jpeg,image/png,image/bmp,image/gif" disabled>
    </div></td></tr>
    <tr><td>
      <div id="img"></div>
    </td></tr>
    <tr><td>
      <canvas id="canvas" width="128" height="160"></canvas>
    </td></tr>
  </table>
</div>

<div id="print"></div>

<script>
'use strict';
var tapORclick = (window.ontouchstart===null) ? "touchstart" : "click";

console.time("start");

var obniz = new Obniz("9659-3725");

//obniz.debugprint = true;

obniz.onconnect = async function () {

/* pin assign
    VCC    6  5v
    GND    5  gnd
    SCL    4  sclk
    SDA    3  mosi
    DC     2  d/cx
    RES    1  reset
    CS     0  chip select
*/
  Obniz.PartsRegistrate(SainSmartTFT18LCD);
  let lcd = obniz.wired("SainSmartTFT18LCD", {scl:4, sda:3, dc:2, res:1, cs:0, vcc:6, gnd:5});

  var rote = 2;
  var grayScale = false;
  console.time("ready");

  lcd.begin();
  lcd.setRotation(rote);
  lcd.fillScreen(ST7735_BLACK);

  $(function() {
    $("#ufile").on("change", function() {
      $("#ufile").attr("disabled", true);
      if (!this.files.length) {
        alert('ファイルが選択されていません');
        return;
      }
      let file = this.files[0];
      let canvas = $("#canvas");
      let context = canvas[0].getContext('2d');
      let canvasWidth = canvas.attr('width');
      let canvasHeight = canvas.attr('height');
      context.fillStyle = "black"; //'#FFFFCC';
      context.fillRect(0, 0, canvasWidth, canvasHeight);
      let image = new Image();
      let fileReader = new FileReader();
      fileReader.onload = function(evt) {
        image.onload = async function() {
            let scale; // w128w x h160 fitting
            let aspectRatio = image.naturalWidth / image.naturalHeight;  //横/縦
            if (aspectRatio > 1.0) {
                // 横長
                scale = lcd.width / image.naturalWidth;
            } else /*if (aspectRatio <= 1.0)*/ {
                // 縦長 or 正方形
                scale = lcd.height / image.naturalHeight;
            }
            let scaledHeight, scaledWidth;
            if (scale < 1) {
                //縮小
                scaledWidth = Math.floor(image.naturalWidth * scale);
                scaledHeight = Math.floor(image.naturalHeight * scale);
            /*canvas.attr('width', scaledWidth);
                canvas.attr('height', scaledHeight);*/
            } else {
                //縮小不要
                scaledWidth = image.naturalWidth;
                scaledHeight = image.naturalHeight;
            }
            let x = Math.round((canvasWidth - scaledWidth)/2);
            let y = Math.round((canvasHeight - scaledHeight)/2);
            context.drawImage(image, x, y, scaledWidth, scaledHeight);
            let info = "size: W" + scaledWidth + "× H" + scaledHeight;

            $("#img").text(info);
            lcd.draw(context, grayScale);
            await obniz.wait(1);
        }
        image.src = evt.target.result;
      }
      fileReader.readAsDataURL(file);
    });
  });

  obniz.switch.onchange = function(state) {
    $('#print').text(state);
    obniz.display.clear();
    obniz.display.print(state);
  }

  function _min(x) {
    let args = Array.prototype.slice.call(arguments, 0);
    var minValue = Number.MAX_VALUE;
    args.forEach(function(v) { if (v < minValue) minValue = v; });
    return minValue;
  }

  $("#sel").on("change", async function() {
    $("#sel").attr("disabled", true);
    $("#ufile").attr("disabled", true);
    let no = Number($("#sel").val());

    $("#img").text("run "+no);
    console.log("run "+no);
    let cl = [ST7735_WHITE, ST7735_YELLOW, ST7735_CYAN, ST7735_GREEN, ST7735_MAGENTA, ST7735_RED, ST7735_BLUE];
    switch (no) {
    case 0: //塗りつぶし
      console.time("fillscreen");
      for (let n=0; n<10; n++) {
        let c = Math.floor(Math.random() * 7);
        lcd.fillScreen(cl[c]);
        await obniz.wait(1);
      }
      console.timeEnd("fillscreen");
      lcd.fillScreen(ST7735_BLACK);
      break;

    case 1: //線
      console.time("line");
      for (let n=0; n<10; n++) {
        let c = n % 7;
        let x = Math.floor(Math.random() * 128);
        let y = Math.floor(Math.random() * 160);
        let w = Math.floor(Math.random() * 128);
        let h = Math.floor(Math.random() * 160);
        lcd.print_debug(x, y, w, h, c);
        lcd.drawLine(x, y, w, h, cl[c]);
        await obniz.wait(1);
      }
      console.timeEnd("line");
      break;

    case 2: { //四角
      let f = [
        function(x,y,w,h,r,c) {lcd.drawRect(x, y, w, h, c);},
        function(x,y,w,h,r,c) {lcd.fillRect(x, y, w, h, c);},
        function(x,y,w,h,r,c) {lcd.drawRoundRect(x, y, w, h, r, c);},
        function(x,y,w,h,r,c) {lcd.fillRoundRect(x, y, w, h, r, c);}
      ];
      for (let n=0; n<10; n++) {
        let round = Math.floor(Math.random() * 2);
        let fill = Math.floor(Math.random() * 2);
        let c =  n % 7;
        let x = Math.floor(Math.random() * 110);
        let y = Math.floor(Math.random() * 150);
        let w = Math.floor(Math.random() * (110-x))+10;
        let h = Math.floor(Math.random() * (150-y))+10;
        let r = Math.floor(Math.random() * _min(3, h, w))+1;
        lcd.print_debug("Rect: ", round, fill, c, x, y, w, h, r, "="+(w*h));
        f[fill](x, y, w, h, r, cl[c]);
        await obniz.wait(1);
      }}
      break;

    case 3: //三角
      for (let n=0; n<10; n++) {
        let fill = Math.floor(Math.random() * 2);
        let c = n % 7;
        let x0 = Math.floor(Math.random() * 120);
        let y0 = Math.floor(Math.random() * 150);
        let x1 = Math.floor(Math.random() * 120);
        let y1 = Math.floor(Math.random() * 150);
        let x2 = Math.floor(Math.random() * 120);
        let y2 = Math.floor(Math.random() * 150);
        lcd.print_debug(fill, x0, y0, x1, y1, x2, y2, c);
        if (fill==1) lcd.fillTriangle(x0, y0, x1, y1, x2, y2, cl[c]);
        else         lcd.drawTriangle(x0, y0, x1, y1, x2, y2, cl[c]);
        await obniz.wait(1);
      }
      break;

    case 4: //丸
      for (let n=0; n<10; n++) {
        let fill = Math.floor(Math.random() * 2);
        let c = n % 7;
        let x = Math.floor(Math.random() * 120);
        let y = Math.floor(Math.random() * 150);
        let r = Math.floor(Math.random() * 60);
        lcd.print_debug(fill, x, y, r, c);
        if (fill==1) lcd.fillCircle(x, y, r, cl[c]);
        else         lcd.drawCircle(x, y, r, cl[c]);
        await obniz.wait(1);
      }
      break;

    case 5: { //文字
      var x = 0, y = 0;
      for (let n=0; n<10; n++) {
        let color = cl[n % 7];
        let size = (n % 4)+1;
        let ret = lcd.drawString(x, y, "ABCabc123", color, ST7735_BLACK, size, true);
        await obniz.wait(1);
        x = ret[0], y = ret[1];
        if (y > 160) y = 0;
      }}
      break;

    case 6: //反転
      for (let n=0; n<2; n++) {
        lcd.writeCommand(ST7735_INVON);
        await obniz.wait(300);
        lcd.writeCommand(ST7735_INVOFF);
        await obniz.wait(300);
      }
      for (let n=0; n<10; n++) {
        lcd.writeCommand(ST7735_INVON);
        await obniz.wait(20);
        lcd.writeCommand(ST7735_INVOFF);
        await obniz.wait(20);
      }
      break;

    case 7: //white
      lcd.fillScreen(ST7735_WHITE);
      break;

    case 8: //black
      lcd.fillScreen(ST7735_BLACK);
      break;

    case 9:
    case 10: {
      alert("すごく時間が掛かります!!");
      lcd.fillScreen(ST7735_BLACK);
      await obniz.wait(1);
      console.time("sentence");
      var c = 0, x = 0, y = 0;
      let ch  = (no == 9) ? 1 : (lcd.width / 6); // 6 pixels per character
      const lcdDescription = 'SainSmart 1.8" TFT LCD Display is an LCD with 128x160 color pixels and SPI interface, transmissive and normally white. It is 256K colors and have little space so we placed a microSD card holder so you can easily load full color bitmaps from a FAT16/FAT32 fromatted microSD card. The screen includes a controller ST7735R which can display full 18-bit color(262,144 shades!).It is also compatible with 3.3V/5V TTL logic. ';
      let len = lcdDescription.length;
      while (c < len) {
        let str = lcdDescription.substr(c, ch);
        let ret = lcd.drawString(x, y, str, ST7735_WHITE, ST7735_WHITE, 1, true);
        c += ch;
        x = ret[0];
        y = ret[1];
        await obniz.wait(10);
      }
      console.timeEnd("sentence");
      }
      break;

    case 11:
      lcd.setRotation(++rote);
      printCenter("ready", ST7735_WHITE, ST7735_WHITE, 1, true);
      await obniz.wait(1);
    break;

    case 12: //draw color image
      alert('「ファイルを選択」からイメージファイルを選択してください。');
      grayScale = false;
      $("#ufile").attr("disabled", false);
      break;

    case 13: //draw gray-scale image
      alert('「ファイルを選択」からイメージファイルを選択してください。');
      grayScale = true;
      $("#ufile").attr("disabled", false);
      break;

    default:
    }
    console.log("compleating...");
//  printCenter("compleate", ST7735_WHITE, ST7735_BLACK, 1, true);
    $("#img").text("compleate");
    console.log("compleate");

    $("#sel").prop('selectedIndex', -1);
    $("#sel").attr("disabled", false);
  });

  printCenter("ready", ST7735_WHITE, ST7735_WHITE, 1, true);

  $("#img").text("ready");  //
  console.timeEnd("ready");

  $("#panel").css("display", "block");
  $("#sel").attr("disabled", false);

  function printCenter(str, color, bg, size, wrap) {
    let len = str.length;
    let x = (lcd.width - len * 6) / 2;
    let y = (lcd.height - 1 * 8) / 2;
    lcd.drawString(x, y, str, color, bg, size, wrap);
  }

}

//--------------------------------------------------------------
//SainSmart ST7735 1.8" TFT LCD 128x160 pixel
class SainSmartTFT18LCD {
  constructor() {
    this.keys = ['vcc', 'gnd', 'scl', 'sda', 'dc', 'res', 'cs'];
    this.required = ['scl', 'sda', 'dc', 'res', 'cs'];
  }

  static info() {
    return {
      name: 'SainSmartTFT18LCD',
    };
  }

  wired(obniz) {
    this.debugprint = false;
    this.obniz = obniz;
    this.io_dc = obniz.getIO(this.params.dc);
    this.io_res = obniz.getIO(this.params.res);
    this.io_cs = obniz.getIO(this.params.cs);

    this.obniz.setVccGnd(this.params.vcc, this.params.gnd, '5v');
    this.params.frequency = 16 * 1000 * 1000; //16MHz
    this.params.mode = 'master';
    this.params.clk = this.params.scl;
    this.params.mosi = this.params.sda;
    this.params.drive = '3v';
    this.spi = this.obniz.getSpiWithConfig(this.params);

    this.io_dc.output(true);
    this.io_cs.output(false);

    this.width = ST7735_TFTWIDTH;
    this.height = ST7735_TFTHEIGHT;

    this.writeBuffer = []; //1024bytes bufferring

    let ioNames = {};
    ioNames[this.params.vcc] = 'vcc';
    ioNames[this.params.gnd] = 'gnd';
    ioNames[this.params.scl] = 'scl';
    ioNames[this.params.sda] = 'sda';
    ioNames[this.params.dc] = 'rs/dc';
    ioNames[this.params.res] = 'res';
    ioNames[this.params.cs] = 'cs';
    this.obniz.display.setPinNames('TFT18', ioNames);

    this.setColorCode();
    this.begin();
  }

  print_debug(v) {
    if (this.debugprint) {
      console.log('SainSmartTFT18LCD: ' + Array.prototype.slice.call(arguments).join(''));
    }
  }
  _deadSleep(waitMsec) {
    let startMsec = new Date();
    while (new Date() - startMsec < waitMsec);
  }
  reset() {
    this.io_res.output(false);
    this._deadSleep(10);
    this.io_res.output(true);
    this._deadSleep(10);
  }

  writeCommand(cmd) {
    this.io_dc.output(false);
    this.io_cs.output(false);
    this.spi.write([cmd]);
    this.io_cs.output(true);
  }

  writeData(data) {
    this.io_dc.output(true);
    this.io_cs.output(false);
    this.spi.write(data);
    this.io_cs.output(true);
  }

  write(cmd, data) {
    if (data.length == 0) return;
    this.writeCommand(cmd);
    this.writeData(data);
  }
  async asyncwait() {
    return await this.spi.writeWait([0x00]);
  }
  write_flush() {
    while (this.writeBuffer.length > 0) {
      if (this.writeBuffer.length > 1024) {
        let data = this.writeBuffer.slice(0, 1024);
        this.writeData(data);
        this.writeBuffer.splice(0, 1024);
      } else {
        if (this.writeBuffer.length > 0) this.writeData(this.writeBuffer);
        this.writeBuffer = [];
      }
    }
  }
  write_buffer(data) {
    if (data && data.length > 0) {
      this.writeBuffer = this.writeBuffer.concat(data);
    } else {
      this.write_flush();
    }
  }

  color16(r, g, b) {
//    this.writeData(r & 0xF8 | g >> 5)
//    this.writeData(g & 0xFC << 3 | b >> 3)
    return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
  }

  initG() {
    this.writeCommand(ST7735_SLPOUT);    //Sleep out & booster on
    this.obniz.wait(120);
    this.write(ST7735_FRMCTR1, [0x01, 0x2C, 0x2D]);
    this.write(ST7735_FRMCTR2, [0x01, 0x2C, 0x2D]);
    this.write(ST7735_FRMCTR3, [0x01, 0x2C, 0x2D, 0x01, 0x2C, 0x2D]);
    this.write(ST7735_INVCTR, [0x07]);
    this.write(ST7735_PWCTR1, [0xA2, 0x02, 0x84]);
    this.write(ST7735_PWCTR2, [0xC5]);
    this.write(ST7735_PWCTR3, [0x0A, 0x00]);
    this.write(ST7735_PWCTR4, [0x8A, 0x2A]);
    this.write(ST7735_PWCTR5, [0x8A, 0xEE]);
    this.write(ST7735_VMCTR1, [0x0E]);
    this.write(ST7735_MADCTL, [0x00]);
    this.write(ST7735_GMCTRP1, [0x02, 0x1C, 0x07, 0x12, 0x37, 0x32, 0x29, 0x2D, 0x29, 0x25, 0x2B, 0x39, 0x00, 0x01, 0x03, 0x10]);
    this.write(ST7735_GMCTRN1, [0x03, 0x1D, 0x07, 0x06, 0x2E, 0x2C, 0x29, 0x2D, 0x2E, 0x2E, 0x37, 0x3F, 0x00, 0x00, 0x02, 0x10]);
    this.write(ST7735_COLMOD, [ST7735_16bit]);   // color format: 16bit/pixel
    this.writeCommand(ST7735_DISPON); //display on
  }

  begin() {
    this.reset();
    this.initG();
    this.setRotation(0);
  }

  setRotation(m) {
    const MADCTL_MY  = 0x80;
    const MADCTL_MX  = 0x40;
    const MADCTL_MV  = 0x20;
    const MADCTL_ML  = 0x10;
    const MADCTL_RGB = 0x00; //always RGB, never BGR
    const MADCTL_MH  = 0x04;

    let data;
    let rotation = m % 4; // can't be higher than 3
    switch (rotation) {
     case 0:
      data = [MADCTL_MX | MADCTL_MY | MADCTL_RGB];
      this.width  = ST7735_TFTWIDTH;
      this.height = ST7735_TFTHEIGHT;
      break;
     case 1:
      data = [MADCTL_MY | MADCTL_MV | MADCTL_RGB];
      this.width  = ST7735_TFTHEIGHT;
      this.height = ST7735_TFTWIDTH;
      break;
     case 2:
      data = [MADCTL_RGB];
      this.width  = ST7735_TFTWIDTH;
      this.height = ST7735_TFTHEIGHT;
      break;
     case 3:
      data = [MADCTL_MX | MADCTL_MV | MADCTL_RGB];
      this.width  = ST7735_TFTHEIGHT;
      this.height = ST7735_TFTWIDTH;
      break;
    }
    this.write(ST7735_MADCTL, data);
    this.setAddrWindow(0, 0, this.width-1, this.height-1);
  }

  setAddrWindow(x0, y0, x1, y1) {
    this.print_debug(`setAddrWindow: (x0: ${x0}, y0: ${y0}) - (x1: ${x1}, y1: ${y1})`);

    if (x0 < 0) x0 = 0;
    if (y0 < 0) y0 = 0;
    if (x1 < 0) x1 = 0;
    if (y1 < 0) y1 = 0;

  // column addr set
    this.write(ST7735_CASET, [0x00, x0, 0x00, x1]); // XSTART-XEND
  // row addr set
    this.write(ST7735_RASET, [0x00, y0, 0x00, y1]);  // YSTART-YEND
  // write to RAM
    this.writeCommand(ST7735_RAMWR);
    this.writeBuffer = [];
  }

//__swap(a, b) { let t = a; a = b; b = t; }

  fillScreen(color) {
    this.fillRect(0, 0, this.width, this.height, color);
  }
  fillRect(x, y, w, h, color) {
    // rudimentary clipping (drawChar w/big text requires this)
    if ((x >= this.width) || (y >= this.height)) return;
    if ((x + w - 1) >= this.width)  w = this.width  - x;
    if ((y + h - 1) >= this.height) h = this.height - y;

    this.setAddrWindow(x, y, x+w-1, y+h-1);

    let hi = color >> 8, lo = color & 0xFF;
    var data = [];

    for(y=h; y>0; y--) {
      for(x=w; x>0; x--) {
        data.push(hi);
        data.push(lo);
      }
    }
    this.write_buffer(data);
    this.write_buffer(); //for flush
  }
  drawRect(x, y, w, h, color) {
    this.drawHLine(x, y, w, color);
    this.drawHLine(x, y+h-1, w, color);
    this.drawVLine(x, y, h, color);
    this.drawVLine(x+w-1, y, h, color);
  }
  drawCircle(x0, y0, r, color) {
    var f = 1 - r;
    var ddF_x = 1;
    var ddF_y = -2 * r;
    var x = 0;
    var y = r;

    this.drawPixel(x0, y0+r, color);
    this.drawPixel(x0, y0-r, color);
    this.drawPixel(x0+r, y0, color);
    this.drawPixel(x0-r, y0, color);

    while (x<y) {
      if (f >= 0) {
        y--;
        ddF_y += 2;
        f += ddF_y;
      }
      x++;
      ddF_x += 2;
      f += ddF_x;

      this.drawPixel(x0 + x, y0 + y, color);
      this.drawPixel(x0 - x, y0 + y, color);
      this.drawPixel(x0 + x, y0 - y, color);
      this.drawPixel(x0 - x, y0 - y, color);
      this.drawPixel(x0 + y, y0 + x, color);
      this.drawPixel(x0 - y, y0 + x, color);
      this.drawPixel(x0 + y, y0 - x, color);
      this.drawPixel(x0 - y, y0 - x, color);
    }
  }
  drawCircleHelper(x0, y0, r, cornername, color) {
    var f = 1 - r;
    var ddF_x = 1;
    var ddF_y = -2 * r;
    var x = 0;
    var y = r;

    while (x<y) {
      if (f >= 0) {
        y--;
        ddF_y += 2;
        f     += ddF_y;
      }
      x++;
      ddF_x += 2;
      f     += ddF_x;
      if (cornername & 0x4) {
        this.drawPixel(x0 + x, y0 + y, color);
        this.drawPixel(x0 + y, y0 + x, color);
      }
      if (cornername & 0x2) {
        this.drawPixel(x0 + x, y0 - y, color);
        this.drawPixel(x0 + y, y0 - x, color);
      }
      if (cornername & 0x8) {
        this.drawPixel(x0 - y, y0 + x, color);
        this.drawPixel(x0 - x, y0 + y, color);
      }
      if (cornername & 0x1) {
        this.drawPixel(x0 - y, y0 - x, color);
        this.drawPixel(x0 - x, y0 - y, color);
      }
    }
  }
  fillCircle(x0, y0, r, color) {
    this.drawVLine(x0, y0-r, 2*r+1, color);
    this.fillCircleHelper(x0, y0, r, 3, 0, color);
  }
  fillCircleHelper(x0, y0, r, cornername, delta, color) {
    var f = 1 - r;
    var ddF_x = 1;
    var ddF_y = -2 * r;
    var x = 0;
    var y = r;

    while (x<y) {
      if (f >= 0) {
        y--;
        ddF_y += 2;
        f     += ddF_y;
      }
      x++;
      ddF_x += 2;
      f     += ddF_x;

      if (cornername & 0x1) {
        this.drawVLine(x0+x, y0-y, 2*y+1+delta, color);
        this.drawVLine(x0+y, y0-x, 2*x+1+delta, color);
      }
      if (cornername & 0x2) {
        this.drawVLine(x0-x, y0-y, 2*y+1+delta, color);
        this.drawVLine(x0-y, y0-x, 2*x+1+delta, color);
      }
    }
  }
  drawRoundRect(x, y, w, h, r, color) {
    // smarter version
    this.drawHLine(x+r  , y    , w-2*r, color); // Top
    this.drawHLine(x+r  , y+h-1, w-2*r, color); // Bottom
    this.drawVLine(x    , y+r  , h-2*r, color); // Left
    this.drawVLine(x+w-1, y+r  , h-2*r, color); // Right

    // draw four corners
    this.drawCircleHelper(x+r    , y+r    , r, 1, color);
    this.drawCircleHelper(x+w-r-1, y+r    , r, 2, color);
    this.drawCircleHelper(x+w-r-1, y+h-r-1, r, 4, color);
    this.drawCircleHelper(x+r    , y+h-r-1, r, 8, color);
  }
  fillRoundRect(x, y, w, h, r, color) {
    // smarter version
    this.fillRect(x+r, y, w-2*r, h, color);

    // draw four corners
    this.fillCircleHelper(x+w-r-1, y+r, r, 1, h-2*r-1, color);
    this.fillCircleHelper(x+r    , y+r, r, 2, h-2*r-1, color);
  }
  drawTriangle(x0, y0, x1, y1, x2, y2, color) {
    this.drawLine(x0, y0, x1, y1, color);
    this.drawLine(x1, y1, x2, y2, color);
    this.drawLine(x2, y2, x0, y0, color);
  }
  fillTriangle (x0, y0, x1, y1, x2, y2, color) {
    var a, b, y, last;

    // Sort coordinates by Y order (y2 >= y1 >= y0)
    if (y0 > y1) {
      y1 = [y0, y0 = y1][0]; //this._swap(y0, y1);
      x1 = [x0, x0 = x1][0]; //this._swap(x0, x1);
    }
    if (y1 > y2) {
      y2 = [y1, y1 = y2][0]; //this._swap(y2, y1);
      x2 = [x1, x1 = x2][0]; //this._swap(x2, x1);
    }
    if (y0 > y1) {
      y1 = [y0, y0 = y1][0]; //this._swap(y0, y1);
      x1 = [x0, x0 = x1][0]; //this._swap(x0, x1);
    }

    if(y0 == y2) { // Handle awkward all-on-same-line case as its own thing
      a = b = x0;
      if (x1 < a)      a = x1;
      else if (x1 > b) b = x1;
      if (x2 < a)      a = x2;
      else if (x2 > b) b = x2;
      this.drawHLine(a, y0, b-a+1, color);
      return;
    }

    var
      dx01 = x1 - x0,
      dy01 = y1 - y0,
      dx02 = x2 - x0,
      dy02 = y2 - y0,
      dx12 = x2 - x1,
      dy12 = y2 - y1,
      sa   = 0,
      sb   = 0;

    // For upper part of triangle, find scanline crossings for segments
    // 0-1 and 0-2.  If y1=y2 (flat-bottomed triangle), the scanline y1
    // is included here (and second loop will be skipped, avoiding a /0
    // error there), otherwise scanline y1 is skipped here and handled
    // in the second loop...which also avoids a /0 error here if y0=y1
    // (flat-topped triangle).
    if (y1 == y2) last = y1;   // Include y1 scanline
    else          last = y1-1; // Skip it

    for (y=y0; y<=last; y++) {
      a   = x0 + Math.floor(sa / dy01);
      b   = x0 + Math.floor(sb / dy02);
      sa += dx01;
      sb += dx02;
      /* longhand:
      a = x0 + (x1 - x0) * (y - y0) / (y1 - y0);
      b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);
      */
      if (a > b) b = [a, a = b][0]; //this._swap(a,b);
      this.drawHLine(a, y, b-a+1, color);
    }

    // For lower part of triangle, find scanline crossings for segments
    // 0-2 and 1-2.  This loop is skipped if y1=y2.
    sa = dx12 * (y - y1);
    sb = dx02 * (y - y0);
    for (; y<=y2; y++) {
      a   = x1 + Math.floor(sa / dy12);
      b   = x0 + Math.floor(sb / dy02);
      sa += dx12;
      sb += dx02;
      /* longhand:
      a = x1 + (x2 - x1) * (y - y1) / (y2 - y1);
      b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);
      */
      if (a > b) b = [a, a = b][0]; //this._swap(a,b);
      this.drawHLine(a, y, b-a+1, color);
    }
  }
  drawVLine(x, y, h, color) {
    // Rudimentary clipping
    if ((x >= this.width) || (y >= this.height)) return;
    if((y+h-1) >= this.height) h = this.height-y;

    this.setAddrWindow(x, y, x, y+h-1);

    let hi = color >> 8, lo = color & 0xFF;
    var data = [];
    while (h--) {
      data.push(hi);
      data.push(lo);
    }
    this.writeData(data);
  }
  drawHLine(x, y, w, color) {
    // Rudimentary clipping
    if ((x >= this.width) || (y >= this.height)) return;
    if ((x+w-1) >= this.width)  w = this.width-x;

    this.setAddrWindow(x, y, x+w-1, y);

    let hi = color >> 8, lo = color & 0xFF;
    var data = [];
    while (w--) {
      data.push(hi);
      data.push(lo);
    }
    this.writeData(data);
  }
  drawLine(x0, y0, x1, y1, color) {
    let steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);
    if (steep) {
      y0 = [x0, x0 = y0][0]; //this._swap(x0, y0);
      y1 = [x1, x1 = y1][0]; //this._swap(x1, y1);
    }
    if (x0 > x1) {
      x1 = [x0, x0 = x1][0]; //this._swap(x0, x1);
      y1 = [y0, y0 = y1][0]; //this._swap(y0, y1);
    }

    let dx = x1 - x0;
    let dy = Math.abs(y1 - y0);

    let err = dx / 2;
    let ystep = (y0 < y1) ? 1 : -1;

    for (; x0<=x1; x0++) {
      if (steep) {
        this.drawPixel(y0, x0, color);
      } else {
        this.drawPixel(x0, y0, color);
      }
      err -= dy;
      if (err < 0) {
        y0 += ystep;
        err += dx;
      }
    }
  }
  drawPixel(x, y, color) {
    if ((x < 0) ||(x >= this.width) || (y < 0) || (y >= this.height)) return;

    this.setAddrWindow(x, y, x+1, y+1);
    this.writeData([color >> 8, color & 0xFF]);
  }
  drawChar(x, y, ch, color, bg, size) {
  if ((x >= this.width)		|| // Clip right
      (y >= this.height)		|| // Clip bottom
     ((x + 6 * size - 1) < 0)	|| // Clip left
     ((y + 8 * size - 1) < 0))     // Clip top
    return;

    let c = ch.charCodeAt(0);
    for (let i=0; i<6; i++) {
      var line = (i == 5) ? 0x0 : font[(c*5)+i];
      for (let j = 0; j<8; j++) {
        if (line & 0x1) {
          if (size == 1) // default size
            this.drawPixel(x+i, y+j, color);
          else {  // big size
            this.fillRect(x+(i*size), y+(j*size), size, size, color);
          }
        } else if (bg != color) {
          if (size == 1) // default size
            this.drawPixel(x+i, y+j, bg);
          else {  // big size
            this.fillRect(x+i*size, y+j*size, size, size, bg);
          } 	
        }
        line >>= 1;
      }
    }
  }
  drawString(x, y, str, color, bg, size, wrap) {
    for (let n=0; n<str.length; n++) {
      let c = str.charAt(n);
      if (c == '\n') {
        y += size*8;
        x = 0;
      } else if (c == '\r') {
        // skip em
      } else {
        this.drawChar(x, y, c, color, bg, size);
        x += size*6;
        if (wrap && (x > (this.width - size*6))) {
        y += size*8;
        x = 0;
        }
      }
    }
    return [x, y];
  }
  drawBounds(top0, left0, context, top1, left1, width, height, gray) {
    top0 = top0 || 0;
    left0 = left0 || 0;
    top1 = top1 || 0;
    left1 = left1 || 0;
    width = width || context.canvas.clientWidth;
    height = height || context.canvas.clientHeight;
    gray = gray || false;
    this.write(ST7735_COLMOD, [ST7735_18bit]); //18bit/pixel
    let imageData = context.getImageData(top1, left1, width, height).data;
    var rgb = [];
    for (let n=0; n<imageData.length; n+=4) {
      let r = imageData[n+0];
      let g = imageData[n+1];
      let b = imageData[n+2];
      if (!gray) {
        rgb.push(r);
        rgb.push(g);
        rgb.push(b);
      } else {
        let gs = Math.round(0.299*r + 0.587*g + 0.114*b)
        rgb.push(gs);
        rgb.push(gs);
        rgb.push(gs);
      }
    }
    this.setAddrWindow(top0, left0, width-1, height-1);
    this.write_buffer(rgb);
    this.write_buffer(); //for flush
    this.write(ST7735_COLMOD, [ST7735_16bit]); //16bit/pixel
  }
  draw(context, gray) {
    gray = gray || false;
    this.drawBounds(0, 0, context, 0, 0, this.width, this.height, gray)
  }
  
  setColorCode() {
this.color.AliceBlue 			= ((0xF0 & 0xF8) << 8) | ((0xF8 & 0xFC) << 3) | (0xFF >> 3);
this.color.AntiqueWhite 		= ((0xFA & 0xF8) << 8) | ((0xEB & 0xFC) << 3) | (0xD7 >> 3);
this.color.Aqua 				= ((0x00 & 0xF8) << 8) | ((0xFF & 0xFC) << 3) | (0xFF >> 3);
this.color.Aquamarine 			= ((0x7F & 0xF8) << 8) | ((0xFF & 0xFC) << 3) | (0xD4 >> 3);
this.color.Azure 				= ((0xF0 & 0xF8) << 8) | ((0xFF & 0xFC) << 3) | (0xFF >> 3);
this.color.Beige 				= ((0xF5 & 0xF8) << 8) | ((0xF5 & 0xFC) << 3) | (0xDC >> 3);
this.color.Bisque 				= ((0xFF & 0xF8) << 8) | ((0xE4 & 0xFC) << 3) | (0xC4 >> 3);
this.color.Black 				= ((0x00 & 0xF8) << 8) | ((0x00 & 0xFC) << 3) | (0x00 >> 3);
this.color.BlanchedAlmond 		= ((0xFF & 0xF8) << 8) | ((0xEB & 0xFC) << 3) | (0xCD >> 3);
this.color.Blue 				= ((0x00 & 0xF8) << 8) | ((0x00 & 0xFC) << 3) | (0xFF >> 3);
this.color.BlueViolet 			= ((0x8A & 0xF8) << 8) | ((0x2B & 0xFC) << 3) | (0xE2 >> 3);
this.color.Brown 				= ((0xA5 & 0xF8) << 8) | ((0x2A & 0xFC) << 3) | (0x2A >> 3);
this.color.BurlyWood 			= ((0xDE & 0xF8) << 8) | ((0xB8 & 0xFC) << 3) | (0x87 >> 3);
this.color.CadetBlue 			= ((0x5F & 0xF8) << 8) | ((0x9E & 0xFC) << 3) | (0xA0 >> 3);
this.color.Chartreuse 			= ((0x7F & 0xF8) << 8) | ((0xFF & 0xFC) << 3) | (0x00 >> 3);
this.color.Chocolate 			= ((0xD2 & 0xF8) << 8) | ((0x69 & 0xFC) << 3) | (0x1E >> 3);
this.color.Coral 				= ((0xFF & 0xF8) << 8) | ((0x7F & 0xFC) << 3) | (0x50 >> 3);
this.color.CornflowerBlue 		= ((0x64 & 0xF8) << 8) | ((0x95 & 0xFC) << 3) | (0xED >> 3);
this.color.Cornsilk 			= ((0xFF & 0xF8) << 8) | ((0xF8 & 0xFC) << 3) | (0xDC >> 3);
this.color.Crimson 				= ((0xDC & 0xF8) << 8) | ((0x14 & 0xFC) << 3) | (0x3C >> 3);
this.color.Cyan 				= ((0x00 & 0xF8) << 8) | ((0xFF & 0xFC) << 3) | (0xFF >> 3);
this.color.DarkBlue 			= ((0x00 & 0xF8) << 8) | ((0x00 & 0xFC) << 3) | (0x8B >> 3);
this.color.DarkCyan 			= ((0x00 & 0xF8) << 8) | ((0x8B & 0xFC) << 3) | (0x8B >> 3);
this.color.DarkGoldenRod 		= ((0xB8 & 0xF8) << 8) | ((0x86 & 0xFC) << 3) | (0x0B >> 3);
this.color.DarkGray 			= ((0xA9 & 0xF8) << 8) | ((0xA9 & 0xFC) << 3) | (0xA9 >> 3);
this.color.DarkGreen 			= ((0x00 & 0xF8) << 8) | ((0x64 & 0xFC) << 3) | (0x00 >> 3);
this.color.DarkKhaki 			= ((0xBD & 0xF8) << 8) | ((0xB7 & 0xFC) << 3) | (0x6B >> 3);
this.color.DarkMagenta 			= ((0x8B & 0xF8) << 8) | ((0x00 & 0xFC) << 3) | (0x8B >> 3);
this.color.DarkOliveGreen 		= ((0x55 & 0xF8) << 8) | ((0x6B & 0xFC) << 3) | (0x2F >> 3);
this.color.DarkOrange 			= ((0xFF & 0xF8) << 8) | ((0x8C & 0xFC) << 3) | (0x00 >> 3);
this.color.DarkOrchid 			= ((0x99 & 0xF8) << 8) | ((0x32 & 0xFC) << 3) | (0xCC >> 3);
this.color.DarkRed 				= ((0x8B & 0xF8) << 8) | ((0x00 & 0xFC) << 3) | (0x00 >> 3);
this.color.DarkSalmon 			= ((0xE9 & 0xF8) << 8) | ((0x96 & 0xFC) << 3) | (0x7A >> 3);
this.color.DarkSeaGreen 		= ((0x8F & 0xF8) << 8) | ((0xBC & 0xFC) << 3) | (0x8F >> 3);
this.color.DarkSlateBlue 		= ((0x48 & 0xF8) << 8) | ((0x3D & 0xFC) << 3) | (0x8B >> 3);
this.color.DarkSlateGray 		= ((0x2F & 0xF8) << 8) | ((0x4F & 0xFC) << 3) | (0x4F >> 3);
this.color.DarkTurquoise 		= ((0x00 & 0xF8) << 8) | ((0xCE & 0xFC) << 3) | (0xD1 >> 3);
this.color.DarkViolet 			= ((0x94 & 0xF8) << 8) | ((0x00 & 0xFC) << 3) | (0xD3 >> 3);
this.color.DeepPink 			= ((0xFF & 0xF8) << 8) | ((0x14 & 0xFC) << 3) | (0x93 >> 3);
this.color.DeepSkyBlue 			= ((0x00 & 0xF8) << 8) | ((0xBF & 0xFC) << 3) | (0xFF >> 3);
this.color.DimGray 				= ((0x69 & 0xF8) << 8) | ((0x69 & 0xFC) << 3) | (0x69 >> 3);
this.color.DodgerBlue 			= ((0x1E & 0xF8) << 8) | ((0x90 & 0xFC) << 3) | (0xFF >> 3);
this.color.FireBrick 			= ((0xB2 & 0xF8) << 8) | ((0x22 & 0xFC) << 3) | (0x22 >> 3);
this.color.FloralWhite 			= ((0xFF & 0xF8) << 8) | ((0xFA & 0xFC) << 3) | (0xF0 >> 3);
this.color.ForestGreen 			= ((0x22 & 0xF8) << 8) | ((0x8B & 0xFC) << 3) | (0x22 >> 3);
this.color.Fuchsia 				= ((0xFF & 0xF8) << 8) | ((0x00 & 0xFC) << 3) | (0xFF >> 3);
this.color.Gainsboro 			= ((0xDC & 0xF8) << 8) | ((0xDC & 0xFC) << 3) | (0xDC >> 3);
this.color.GhostWhite 			= ((0xF8 & 0xF8) << 8) | ((0xF8 & 0xFC) << 3) | (0xFF >> 3);
this.color.Gold 				= ((0xFF & 0xF8) << 8) | ((0xD7 & 0xFC) << 3) | (0x00 >> 3);
this.color.GoldenRod 			= ((0xDA & 0xF8) << 8) | ((0xA5 & 0xFC) << 3) | (0x20 >> 3);
this.color.Gray 				= ((0x80 & 0xF8) << 8) | ((0x80 & 0xFC) << 3) | (0x80 >> 3);
this.color.Green 				= ((0x00 & 0xF8) << 8) | ((0x80 & 0xFC) << 3) | (0x00 >> 3);
this.color.GreenYellow 			= ((0xAD & 0xF8) << 8) | ((0xFF & 0xFC) << 3) | (0x2F >> 3);
this.color.HoneyDew 			= ((0xF0 & 0xF8) << 8) | ((0xFF & 0xFC) << 3) | (0xF0 >> 3);
this.color.HotPink 				= ((0xFF & 0xF8) << 8) | ((0x69 & 0xFC) << 3) | (0xB4 >> 3);
this.color.IndianRed  			= ((0xCD & 0xF8) << 8) | ((0x5C & 0xFC) << 3) | (0x5C >> 3);
this.color.Indigo  				= ((0x4B & 0xF8) << 8) | ((0x00 & 0xFC) << 3) | (0x82 >> 3);
this.color.Ivory 				= ((0xFF & 0xF8) << 8) | ((0xFF & 0xFC) << 3) | (0xF0 >> 3);
this.color.Khaki 				= ((0xF0 & 0xF8) << 8) | ((0xE6 & 0xFC) << 3) | (0x8C >> 3);
this.color.Lavender 			= ((0xE6 & 0xF8) << 8) | ((0xE6 & 0xFC) << 3) | (0xFA >> 3);
this.color.LavenderBlush 		= ((0xFF & 0xF8) << 8) | ((0xF0 & 0xFC) << 3) | (0xF5 >> 3);
this.color.LawnGreen 			= ((0x7C & 0xF8) << 8) | ((0xFC & 0xFC) << 3) | (0x00 >> 3);
this.color.LemonChiffon 		= ((0xFF & 0xF8) << 8) | ((0xFA & 0xFC) << 3) | (0xCD >> 3);
this.color.LightBlue 			= ((0xAD & 0xF8) << 8) | ((0xD8 & 0xFC) << 3) | (0xE6 >> 3);
this.color.LightCoral 			= ((0xF0 & 0xF8) << 8) | ((0x80 & 0xFC) << 3) | (0x80 >> 3);
this.color.LightCyan 			= ((0xE0 & 0xF8) << 8) | ((0xFF & 0xFC) << 3) | (0xFF >> 3);
this.color.LightGoldenRodYellow = ((0xFA & 0xF8) << 8) | ((0xFA & 0xFC) << 3) | (0xD2 >> 3);
this.color.LightGray 			= ((0xD3 & 0xF8) << 8) | ((0xD3 & 0xFC) << 3) | (0xD3 >> 3);
this.color.LightGreen 			= ((0x90 & 0xF8) << 8) | ((0xEE & 0xFC) << 3) | (0x90 >> 3);
this.color.LightPink 			= ((0xFF & 0xF8) << 8) | ((0xB6 & 0xFC) << 3) | (0xC1 >> 3);
this.color.LightSalmon 			= ((0xFF & 0xF8) << 8) | ((0xA0 & 0xFC) << 3) | (0x7A >> 3);
this.color.LightSeaGreen 		= ((0x20 & 0xF8) << 8) | ((0xB2 & 0xFC) << 3) | (0xAA >> 3);
this.color.LightSkyBlue 		= ((0x87 & 0xF8) << 8) | ((0xCE & 0xFC) << 3) | (0xFA >> 3);
this.color.LightSlateGray 		= ((0x77 & 0xF8) << 8) | ((0x88 & 0xFC) << 3) | (0x99 >> 3);
this.color.LightSteelBlue 		= ((0xB0 & 0xF8) << 8) | ((0xC4 & 0xFC) << 3) | (0xDE >> 3);
this.color.LightYellow 			= ((0xFF & 0xF8) << 8) | ((0xFF & 0xFC) << 3) | (0xE0 >> 3);
this.color.Lime 				= ((0x00 & 0xF8) << 8) | ((0xFF & 0xFC) << 3) | (0x00 >> 3);
this.color.LimeGreen 			= ((0x32 & 0xF8) << 8) | ((0xCD & 0xFC) << 3) | (0x32 >> 3);
this.color.Linen 				= ((0xFA & 0xF8) << 8) | ((0xF0 & 0xFC) << 3) | (0xE6 >> 3);
this.color.Magenta 				= ((0xFF & 0xF8) << 8) | ((0x00 & 0xFC) << 3) | (0xFF >> 3);
this.color.Maroon 				= ((0x80 & 0xF8) << 8) | ((0x00 & 0xFC) << 3) | (0x00 >> 3);
this.color.MediumAquaMarine 	= ((0x66 & 0xF8) << 8) | ((0xCD & 0xFC) << 3) | (0xAA >> 3);
this.color.MediumBlue 			= ((0x00 & 0xF8) << 8) | ((0x00 & 0xFC) << 3) | (0xCD >> 3);
this.color.MediumOrchid 		= ((0xBA & 0xF8) << 8) | ((0x55 & 0xFC) << 3) | (0xD3 >> 3);
this.color.MediumPurple 		= ((0x93 & 0xF8) << 8) | ((0x70 & 0xFC) << 3) | (0xDB >> 3);
this.color.MediumSeaGreen 		= ((0x3C & 0xF8) << 8) | ((0xB3 & 0xFC) << 3) | (0x71 >> 3);
this.color.MediumSlateBlue 		= ((0x7B & 0xF8) << 8) | ((0x68 & 0xFC) << 3) | (0xEE >> 3);
this.color.MediumSpringGreen 	= ((0x00 & 0xF8) << 8) | ((0xFA & 0xFC) << 3) | (0x9A >> 3);
this.color.MediumTurquoise 		= ((0x48 & 0xF8) << 8) | ((0xD1 & 0xFC) << 3) | (0xCC >> 3);
this.color.MediumVioletRed 		= ((0xC7 & 0xF8) << 8) | ((0x15 & 0xFC) << 3) | (0x85 >> 3);
this.color.MidnightBlue 		= ((0x19 & 0xF8) << 8) | ((0x19 & 0xFC) << 3) | (0x70 >> 3);
this.color.MintCream 			= ((0xF5 & 0xF8) << 8) | ((0xFF & 0xFC) << 3) | (0xFA >> 3);
this.color.MistyRose 			= ((0xFF & 0xF8) << 8) | ((0xE4 & 0xFC) << 3) | (0xE1 >> 3);
this.color.Moccasin 			= ((0xFF & 0xF8) << 8) | ((0xE4 & 0xFC) << 3) | (0xB5 >> 3);
this.color.NavajoWhite 			= ((0xFF & 0xF8) << 8) | ((0xDE & 0xFC) << 3) | (0xAD >> 3);
this.color.Navy 				= ((0x00 & 0xF8) << 8) | ((0x00 & 0xFC) << 3) | (0x80 >> 3);
this.color.OldLace 				= ((0xFD & 0xF8) << 8) | ((0xF5 & 0xFC) << 3) | (0xE6 >> 3);
this.color.Olive 				= ((0x80 & 0xF8) << 8) | ((0x80 & 0xFC) << 3) | (0x00 >> 3);
this.color.OliveDrab 			= ((0x6B & 0xF8) << 8) | ((0x8E & 0xFC) << 3) | (0x23 >> 3);
this.color.Orange 				= ((0xFF & 0xF8) << 8) | ((0xA5 & 0xFC) << 3) | (0x00 >> 3);
this.color.OrangeRed 			= ((0xFF & 0xF8) << 8) | ((0x45 & 0xFC) << 3) | (0x00 >> 3);
this.color.Orchid 				= ((0xDA & 0xF8) << 8) | ((0x70 & 0xFC) << 3) | (0xD6 >> 3);
this.color.PaleGoldenRod 		= ((0xEE & 0xF8) << 8) | ((0xE8 & 0xFC) << 3) | (0xAA >> 3);
this.color.PaleGreen 			= ((0x98 & 0xF8) << 8) | ((0xFB & 0xFC) << 3) | (0x98 >> 3);
this.color.PaleTurquoise 		= ((0xAF & 0xF8) << 8) | ((0xEE & 0xFC) << 3) | (0xEE >> 3);
this.color.PaleVioletRed 		= ((0xDB & 0xF8) << 8) | ((0x70 & 0xFC) << 3) | (0x93 >> 3);
this.color.PapayaWhip 			= ((0xFF & 0xF8) << 8) | ((0xEF & 0xFC) << 3) | (0xD5 >> 3);
this.color.PeachPuff 			= ((0xFF & 0xF8) << 8) | ((0xDA & 0xFC) << 3) | (0xB9 >> 3);
this.color.Peru 				= ((0xCD & 0xF8) << 8) | ((0x85 & 0xFC) << 3) | (0x3F >> 3);
this.color.Pink 				= ((0xFF & 0xF8) << 8) | ((0xC0 & 0xFC) << 3) | (0xCB >> 3);
this.color.Plum 				= ((0xDD & 0xF8) << 8) | ((0xA0 & 0xFC) << 3) | (0xDD >> 3);
this.color.PowderBlue 			= ((0xB0 & 0xF8) << 8) | ((0xE0 & 0xFC) << 3) | (0xE6 >> 3);
this.color.Purple 				= ((0x80 & 0xF8) << 8) | ((0x00 & 0xFC) << 3) | (0x80 >> 3);
this.color.RebeccaPurple 		= ((0x66 & 0xF8) << 8) | ((0x33 & 0xFC) << 3) | (0x99 >> 3);
this.color.Red 					= ((0xFF & 0xF8) << 8) | ((0x00 & 0xFC) << 3) | (0x00 >> 3);
this.color.RosyBrown 			= ((0xBC & 0xF8) << 8) | ((0x8F & 0xFC) << 3) | (0x8F >> 3);
this.color.RoyalBlue 			= ((0x41 & 0xF8) << 8) | ((0x69 & 0xFC) << 3) | (0xE1 >> 3);
this.color.SaddleBrown 			= ((0x8B & 0xF8) << 8) | ((0x45 & 0xFC) << 3) | (0x13 >> 3);
this.color.Salmon 				= ((0xFA & 0xF8) << 8) | ((0x80 & 0xFC) << 3) | (0x72 >> 3);
this.color.SandyBrown 			= ((0xF4 & 0xF8) << 8) | ((0xA4 & 0xFC) << 3) | (0x60 >> 3);
this.color.SeaGreen 			= ((0x2E & 0xF8) << 8) | ((0x8B & 0xFC) << 3) | (0x57 >> 3);
this.color.SeaShell 			= ((0xFF & 0xF8) << 8) | ((0xF5 & 0xFC) << 3) | (0xEE >> 3);
this.color.Sienna 				= ((0xA0 & 0xF8) << 8) | ((0x52 & 0xFC) << 3) | (0x2D >> 3);
this.color.Silver 				= ((0xC0 & 0xF8) << 8) | ((0xC0 & 0xFC) << 3) | (0xC0 >> 3);
this.color.SkyBlue 				= ((0x87 & 0xF8) << 8) | ((0xCE & 0xFC) << 3) | (0xEB >> 3);
this.color.SlateBlue 			= ((0x6A & 0xF8) << 8) | ((0x5A & 0xFC) << 3) | (0xCD >> 3);
this.color.SlateGray 			= ((0x70 & 0xF8) << 8) | ((0x80 & 0xFC) << 3) | (0x90 >> 3);
this.color.Snow 				= ((0xFF & 0xF8) << 8) | ((0xFA & 0xFC) << 3) | (0xFA >> 3);
this.color.SpringGreen 			= ((0x00 & 0xF8) << 8) | ((0xFF & 0xFC) << 3) | (0x7F >> 3);
this.color.SteelBlue 			= ((0x46 & 0xF8) << 8) | ((0x82 & 0xFC) << 3) | (0xB4 >> 3);
this.color.Tan 					= ((0xD2 & 0xF8) << 8) | ((0xB4 & 0xFC) << 3) | (0x8C >> 3);
this.color.Teal 				= ((0x00 & 0xF8) << 8) | ((0x80 & 0xFC) << 3) | (0x80 >> 3);
this.color.Thistle 				= ((0xD8 & 0xF8) << 8) | ((0xBF & 0xFC) << 3) | (0xD8 >> 3);
this.color.Tomato 				= ((0xFF & 0xF8) << 8) | ((0x63 & 0xFC) << 3) | (0x47 >> 3);
this.color.Turquoise 			= ((0x40 & 0xF8) << 8) | ((0xE0 & 0xFC) << 3) | (0xD0 >> 3);
this.color.Violet 				= ((0xEE & 0xF8) << 8) | ((0x82 & 0xFC) << 3) | (0xEE >> 3);
this.color.Wheat 				= ((0xF5 & 0xF8) << 8) | ((0xDE & 0xFC) << 3) | (0xB3 >> 3);
this.color.White 				= ((0xFF & 0xF8) << 8) | ((0xFF & 0xFC) << 3) | (0xFF >> 3);
this.color.WhiteSmoke 			= ((0xF5 & 0xF8) << 8) | ((0xF5 & 0xFC) << 3) | (0xF5 >> 3);
this.color.Yellow 				= ((0xFF & 0xF8) << 8) | ((0xFF & 0xFC) << 3) | (0x00 >> 3);
this.color.YellowGreen 			= ((0x9A & 0xF8) << 8) | ((0xCD & 0xFC) << 3) | (0x32 >> 3);
  }
}

if (typeof module === 'object') {
  module.exports = SainSmartTFT18LCD;
}

//----------------------------------------------------------

// commands
const INITR_GREENTAB = 0x0;
const INITR_REDTAB   = 0x1;
const INITR_BLACKTAB = 0x2;

const ST7735_TFTWIDTH  = 128;
const ST7735_TFTHEIGHT = 160;

const ST7735_NOP     = 0x00;
const ST7735_SWRESET = 0x01;
const ST7735_RDDID   = 0x04;
const ST7735_RDDST   = 0x09;
const ST7735_RDDPM   = 0x0A;

const ST7735_SLPIN   = 0x10;
const ST7735_SLPOUT  = 0x11;
const ST7735_PTLON   = 0x12;
const ST7735_NORON   = 0x13;

const ST7735_INVOFF  = 0x20;
const ST7735_INVON   = 0x21;
const ST7735_DISPOFF = 0x28;
const ST7735_DISPON  = 0x29;
const ST7735_CASET   = 0x2A;
const ST7735_RASET   = 0x2B;
const ST7735_RAMWR   = 0x2C;
const ST7735_RAMRD   = 0x2E;

const ST7735_PTLAR   = 0x30;
const ST7735_COLMOD  = 0x3A;
const ST7735_MADCTL  = 0x36;

const ST7735_FRMCTR1 = 0xB1;
const ST7735_FRMCTR2 = 0xB2;
const ST7735_FRMCTR3 = 0xB3;
const ST7735_INVCTR  = 0xB4;
const ST7735_DISSET5 = 0xB6;

const ST7735_PWCTR1  = 0xC0;
const ST7735_PWCTR2  = 0xC1;
const ST7735_PWCTR3  = 0xC2;
const ST7735_PWCTR4  = 0xC3;
const ST7735_PWCTR5  = 0xC4;
const ST7735_VMCTR1  = 0xC5;

const ST7735_RDID1   = 0xDA;
const ST7735_RDID2   = 0xDB;
const ST7735_RDID3   = 0xDC;
const ST7735_RDID4   = 0xDD;

const ST7735_PWCTR6  = 0xFC;

const ST7735_GMCTRP1 = 0xE0;
const ST7735_GMCTRN1 = 0xE1;

// Color definitions
const ST7735_BLACK   = 0x0000;
const ST7735_BLUE    = 0x001F;
const ST7735_RED     = 0xF800;
const ST7735_GREEN   = 0x07E0;
const ST7735_CYAN    = 0x07FF;
const ST7735_MAGENTA = 0xF81F;
const ST7735_YELLOW  = 0xFFE0;
const ST7735_WHITE   = 0xFFFF;

const ST7735_18bit   = 0x06; // 18bit/pixel
const ST7735_16bit   = 0x05; // 16bit/pixel

// standard ascii 5x7 font
const font = [
  0x00, 0x00, 0x00, 0x00, 0x00,
  0x3E, 0x5B, 0x4F, 0x5B, 0x3E, 	
  0x3E, 0x6B, 0x4F, 0x6B, 0x3E, 	
  0x1C, 0x3E, 0x7C, 0x3E, 0x1C,
  0x18, 0x3C, 0x7E, 0x3C, 0x18,
  0x1C, 0x57, 0x7D, 0x57, 0x1C,
  0x1C, 0x5E, 0x7F, 0x5E, 0x1C,
  0x00, 0x18, 0x3C, 0x18, 0x00,
  0xFF, 0xE7, 0xC3, 0xE7, 0xFF,
  0x00, 0x18, 0x24, 0x18, 0x00,
  0xFF, 0xE7, 0xDB, 0xE7, 0xFF,
  0x30, 0x48, 0x3A, 0x06, 0x0E,
  0x26, 0x29, 0x79, 0x29, 0x26,
  0x40, 0x7F, 0x05, 0x05, 0x07,
  0x40, 0x7F, 0x05, 0x25, 0x3F,
  0x5A, 0x3C, 0xE7, 0x3C, 0x5A,
  0x7F, 0x3E, 0x1C, 0x1C, 0x08,
  0x08, 0x1C, 0x1C, 0x3E, 0x7F,
  0x14, 0x22, 0x7F, 0x22, 0x14,
  0x5F, 0x5F, 0x00, 0x5F, 0x5F,
  0x06, 0x09, 0x7F, 0x01, 0x7F,
  0x00, 0x66, 0x89, 0x95, 0x6A,
  0x60, 0x60, 0x60, 0x60, 0x60,
  0x94, 0xA2, 0xFF, 0xA2, 0x94,
  0x08, 0x04, 0x7E, 0x04, 0x08,
  0x10, 0x20, 0x7E, 0x20, 0x10,
  0x08, 0x08, 0x2A, 0x1C, 0x08,
  0x08, 0x1C, 0x2A, 0x08, 0x08,
  0x1E, 0x10, 0x10, 0x10, 0x10,
  0x0C, 0x1E, 0x0C, 0x1E, 0x0C,
  0x30, 0x38, 0x3E, 0x38, 0x30,
  0x06, 0x0E, 0x3E, 0x0E, 0x06,
  0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x5F, 0x00, 0x00,
  0x00, 0x07, 0x00, 0x07, 0x00,
  0x14, 0x7F, 0x14, 0x7F, 0x14,
  0x24, 0x2A, 0x7F, 0x2A, 0x12,
  0x23, 0x13, 0x08, 0x64, 0x62,
  0x36, 0x49, 0x56, 0x20, 0x50,
  0x00, 0x08, 0x07, 0x03, 0x00,
  0x00, 0x1C, 0x22, 0x41, 0x00,
  0x00, 0x41, 0x22, 0x1C, 0x00,
  0x2A, 0x1C, 0x7F, 0x1C, 0x2A,
  0x08, 0x08, 0x3E, 0x08, 0x08,
  0x00, 0x80, 0x70, 0x30, 0x00,
  0x08, 0x08, 0x08, 0x08, 0x08,
  0x00, 0x00, 0x60, 0x60, 0x00,
  0x20, 0x10, 0x08, 0x04, 0x02,
  0x3E, 0x51, 0x49, 0x45, 0x3E,
  0x00, 0x42, 0x7F, 0x40, 0x00,
  0x72, 0x49, 0x49, 0x49, 0x46,
  0x21, 0x41, 0x49, 0x4D, 0x33,
  0x18, 0x14, 0x12, 0x7F, 0x10,
  0x27, 0x45, 0x45, 0x45, 0x39,
  0x3C, 0x4A, 0x49, 0x49, 0x31,
  0x41, 0x21, 0x11, 0x09, 0x07,
  0x36, 0x49, 0x49, 0x49, 0x36,
  0x46, 0x49, 0x49, 0x29, 0x1E,
  0x00, 0x00, 0x14, 0x00, 0x00,
  0x00, 0x40, 0x34, 0x00, 0x00,
  0x00, 0x08, 0x14, 0x22, 0x41,
  0x14, 0x14, 0x14, 0x14, 0x14,
  0x00, 0x41, 0x22, 0x14, 0x08,
  0x02, 0x01, 0x59, 0x09, 0x06,
  0x3E, 0x41, 0x5D, 0x59, 0x4E,
  0x7C, 0x12, 0x11, 0x12, 0x7C,
  0x7F, 0x49, 0x49, 0x49, 0x36,
  0x3E, 0x41, 0x41, 0x41, 0x22,
  0x7F, 0x41, 0x41, 0x41, 0x3E,
  0x7F, 0x49, 0x49, 0x49, 0x41,
  0x7F, 0x09, 0x09, 0x09, 0x01,
  0x3E, 0x41, 0x41, 0x51, 0x73,
  0x7F, 0x08, 0x08, 0x08, 0x7F,
  0x00, 0x41, 0x7F, 0x41, 0x00,
  0x20, 0x40, 0x41, 0x3F, 0x01,
  0x7F, 0x08, 0x14, 0x22, 0x41,
  0x7F, 0x40, 0x40, 0x40, 0x40,
  0x7F, 0x02, 0x1C, 0x02, 0x7F,
  0x7F, 0x04, 0x08, 0x10, 0x7F,
  0x3E, 0x41, 0x41, 0x41, 0x3E,
  0x7F, 0x09, 0x09, 0x09, 0x06,
  0x3E, 0x41, 0x51, 0x21, 0x5E,
  0x7F, 0x09, 0x19, 0x29, 0x46,
  0x26, 0x49, 0x49, 0x49, 0x32,
  0x03, 0x01, 0x7F, 0x01, 0x03,
  0x3F, 0x40, 0x40, 0x40, 0x3F,
  0x1F, 0x20, 0x40, 0x20, 0x1F,
  0x3F, 0x40, 0x38, 0x40, 0x3F,
  0x63, 0x14, 0x08, 0x14, 0x63,
  0x03, 0x04, 0x78, 0x04, 0x03,
  0x61, 0x59, 0x49, 0x4D, 0x43,
  0x00, 0x7F, 0x41, 0x41, 0x41,
  0x02, 0x04, 0x08, 0x10, 0x20,
  0x00, 0x41, 0x41, 0x41, 0x7F,
  0x04, 0x02, 0x01, 0x02, 0x04,
  0x40, 0x40, 0x40, 0x40, 0x40,
  0x00, 0x03, 0x07, 0x08, 0x00,
  0x20, 0x54, 0x54, 0x78, 0x40,
  0x7F, 0x28, 0x44, 0x44, 0x38,
  0x38, 0x44, 0x44, 0x44, 0x28,
  0x38, 0x44, 0x44, 0x28, 0x7F,
  0x38, 0x54, 0x54, 0x54, 0x18,
  0x00, 0x08, 0x7E, 0x09, 0x02,
  0x18, 0xA4, 0xA4, 0x9C, 0x78,
  0x7F, 0x08, 0x04, 0x04, 0x78,
  0x00, 0x44, 0x7D, 0x40, 0x00,
  0x20, 0x40, 0x40, 0x3D, 0x00,
  0x7F, 0x10, 0x28, 0x44, 0x00,
  0x00, 0x41, 0x7F, 0x40, 0x00,
  0x7C, 0x04, 0x78, 0x04, 0x78,
  0x7C, 0x08, 0x04, 0x04, 0x78,
  0x38, 0x44, 0x44, 0x44, 0x38,
  0xFC, 0x18, 0x24, 0x24, 0x18,
  0x18, 0x24, 0x24, 0x18, 0xFC,
  0x7C, 0x08, 0x04, 0x04, 0x08,
  0x48, 0x54, 0x54, 0x54, 0x24,
  0x04, 0x04, 0x3F, 0x44, 0x24,
  0x3C, 0x40, 0x40, 0x20, 0x7C,
  0x1C, 0x20, 0x40, 0x20, 0x1C,
  0x3C, 0x40, 0x30, 0x40, 0x3C,
  0x44, 0x28, 0x10, 0x28, 0x44,
  0x4C, 0x90, 0x90, 0x90, 0x7C,
  0x44, 0x64, 0x54, 0x4C, 0x44,
  0x00, 0x08, 0x36, 0x41, 0x00,
  0x00, 0x00, 0x77, 0x00, 0x00,
  0x00, 0x41, 0x36, 0x08, 0x00,
  0x02, 0x01, 0x02, 0x04, 0x02,
  0x3C, 0x26, 0x23, 0x26, 0x3C,
  0x1E, 0xA1, 0xA1, 0x61, 0x12,
  0x3A, 0x40, 0x40, 0x20, 0x7A,
  0x38, 0x54, 0x54, 0x55, 0x59,
  0x21, 0x55, 0x55, 0x79, 0x41,
  0x21, 0x54, 0x54, 0x78, 0x41,
  0x21, 0x55, 0x54, 0x78, 0x40,
  0x20, 0x54, 0x55, 0x79, 0x40,
  0x0C, 0x1E, 0x52, 0x72, 0x12,
  0x39, 0x55, 0x55, 0x55, 0x59,
  0x39, 0x54, 0x54, 0x54, 0x59,
  0x39, 0x55, 0x54, 0x54, 0x58,
  0x00, 0x00, 0x45, 0x7C, 0x41,
  0x00, 0x02, 0x45, 0x7D, 0x42,
  0x00, 0x01, 0x45, 0x7C, 0x40,
  0xF0, 0x29, 0x24, 0x29, 0xF0,
  0xF0, 0x28, 0x25, 0x28, 0xF0,
  0x7C, 0x54, 0x55, 0x45, 0x00,
  0x20, 0x54, 0x54, 0x7C, 0x54,
  0x7C, 0x0A, 0x09, 0x7F, 0x49,
  0x32, 0x49, 0x49, 0x49, 0x32,
  0x32, 0x48, 0x48, 0x48, 0x32,
  0x32, 0x4A, 0x48, 0x48, 0x30,
  0x3A, 0x41, 0x41, 0x21, 0x7A,
  0x3A, 0x42, 0x40, 0x20, 0x78,
  0x00, 0x9D, 0xA0, 0xA0, 0x7D,
  0x39, 0x44, 0x44, 0x44, 0x39,
  0x3D, 0x40, 0x40, 0x40, 0x3D,
  0x3C, 0x24, 0xFF, 0x24, 0x24,
  0x48, 0x7E, 0x49, 0x43, 0x66,
  0x2B, 0x2F, 0xFC, 0x2F, 0x2B,
  0xFF, 0x09, 0x29, 0xF6, 0x20,
  0xC0, 0x88, 0x7E, 0x09, 0x03,
  0x20, 0x54, 0x54, 0x79, 0x41,
  0x00, 0x00, 0x44, 0x7D, 0x41,
  0x30, 0x48, 0x48, 0x4A, 0x32,
  0x38, 0x40, 0x40, 0x22, 0x7A,
  0x00, 0x7A, 0x0A, 0x0A, 0x72,
  0x7D, 0x0D, 0x19, 0x31, 0x7D,
  0x26, 0x29, 0x29, 0x2F, 0x28,
  0x26, 0x29, 0x29, 0x29, 0x26,
  0x30, 0x48, 0x4D, 0x40, 0x20,
  0x38, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x08, 0x08, 0x38,
  0x2F, 0x10, 0xC8, 0xAC, 0xBA,
  0x2F, 0x10, 0x28, 0x34, 0xFA,
  0x00, 0x00, 0x7B, 0x00, 0x00,
  0x08, 0x14, 0x2A, 0x14, 0x22,
  0x22, 0x14, 0x2A, 0x14, 0x08,
  0xAA, 0x00, 0x55, 0x00, 0xAA,
  0xAA, 0x55, 0xAA, 0x55, 0xAA,
  0x00, 0x00, 0x00, 0xFF, 0x00,
  0x10, 0x10, 0x10, 0xFF, 0x00,
  0x14, 0x14, 0x14, 0xFF, 0x00,
  0x10, 0x10, 0xFF, 0x00, 0xFF,
  0x10, 0x10, 0xF0, 0x10, 0xF0,
  0x14, 0x14, 0x14, 0xFC, 0x00,
  0x14, 0x14, 0xF7, 0x00, 0xFF,
  0x00, 0x00, 0xFF, 0x00, 0xFF,
  0x14, 0x14, 0xF4, 0x04, 0xFC,
  0x14, 0x14, 0x17, 0x10, 0x1F,
  0x10, 0x10, 0x1F, 0x10, 0x1F,
  0x14, 0x14, 0x14, 0x1F, 0x00,
  0x10, 0x10, 0x10, 0xF0, 0x00,
  0x00, 0x00, 0x00, 0x1F, 0x10,
  0x10, 0x10, 0x10, 0x1F, 0x10,
  0x10, 0x10, 0x10, 0xF0, 0x10,
  0x00, 0x00, 0x00, 0xFF, 0x10,
  0x10, 0x10, 0x10, 0x10, 0x10,
  0x10, 0x10, 0x10, 0xFF, 0x10,
  0x00, 0x00, 0x00, 0xFF, 0x14,
  0x00, 0x00, 0xFF, 0x00, 0xFF,
  0x00, 0x00, 0x1F, 0x10, 0x17,
  0x00, 0x00, 0xFC, 0x04, 0xF4,
  0x14, 0x14, 0x17, 0x10, 0x17,
  0x14, 0x14, 0xF4, 0x04, 0xF4,
  0x00, 0x00, 0xFF, 0x00, 0xF7,
  0x14, 0x14, 0x14, 0x14, 0x14,
  0x14, 0x14, 0xF7, 0x00, 0xF7,
  0x14, 0x14, 0x14, 0x17, 0x14,
  0x10, 0x10, 0x1F, 0x10, 0x1F,
  0x14, 0x14, 0x14, 0xF4, 0x14,
  0x10, 0x10, 0xF0, 0x10, 0xF0,
  0x00, 0x00, 0x1F, 0x10, 0x1F,
  0x00, 0x00, 0x00, 0x1F, 0x14,
  0x00, 0x00, 0x00, 0xFC, 0x14,
  0x00, 0x00, 0xF0, 0x10, 0xF0,
  0x10, 0x10, 0xFF, 0x10, 0xFF,
  0x14, 0x14, 0x14, 0xFF, 0x14,
  0x10, 0x10, 0x10, 0x1F, 0x00,
  0x00, 0x00, 0x00, 0xF0, 0x10,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
  0xFF, 0xFF, 0xFF, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xFF, 0xFF,
  0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
  0x38, 0x44, 0x44, 0x38, 0x44,
  0x7C, 0x2A, 0x2A, 0x3E, 0x14,
  0x7E, 0x02, 0x02, 0x06, 0x06,
  0x02, 0x7E, 0x02, 0x7E, 0x02,
  0x63, 0x55, 0x49, 0x41, 0x63,
  0x38, 0x44, 0x44, 0x3C, 0x04,
  0x40, 0x7E, 0x20, 0x1E, 0x20,
  0x06, 0x02, 0x7E, 0x02, 0x02,
  0x99, 0xA5, 0xE7, 0xA5, 0x99,
  0x1C, 0x2A, 0x49, 0x2A, 0x1C,
  0x4C, 0x72, 0x01, 0x72, 0x4C,
  0x30, 0x4A, 0x4D, 0x4D, 0x30,
  0x30, 0x48, 0x78, 0x48, 0x30,
  0xBC, 0x62, 0x5A, 0x46, 0x3D,
  0x3E, 0x49, 0x49, 0x49, 0x00,
  0x7E, 0x01, 0x01, 0x01, 0x7E,
  0x2A, 0x2A, 0x2A, 0x2A, 0x2A,
  0x44, 0x44, 0x5F, 0x44, 0x44,
  0x40, 0x51, 0x4A, 0x44, 0x40,
  0x40, 0x44, 0x4A, 0x51, 0x40,
  0x00, 0x00, 0xFF, 0x01, 0x03,
  0xE0, 0x80, 0xFF, 0x00, 0x00,
  0x08, 0x08, 0x6B, 0x6B, 0x08,
  0x36, 0x12, 0x36, 0x24, 0x36,
  0x06, 0x0F, 0x09, 0x0F, 0x06,
  0x00, 0x00, 0x18, 0x18, 0x00,
  0x00, 0x00, 0x10, 0x10, 0x00,
  0x30, 0x40, 0xFF, 0x01, 0x01,
  0x00, 0x1F, 0x01, 0x01, 0x1E,
  0x00, 0x19, 0x1D, 0x17, 0x12,
  0x00, 0x3C, 0x3C, 0x3C, 0x3C,
  0x00, 0x00, 0x00, 0x00, 0x00,
];

</script>
</body>
</html>


